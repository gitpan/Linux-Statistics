.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.14
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Linux-Statistics::Statistics 3"
.TH Linux-Statistics::Statistics 3 "2005-12-26" "perl v5.8.6" "User Contributed Perl Documentation"
.SH "NAME"
Linux::Statistics \- Collect system statistics.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
use Linux::Statistics;
.PP
my \f(CW$obj\fR = Linux::Statistics\->new( SysInfo   => 1,
                                  ProcStats => 1,
                                  MemStats  => 1,
                                  PgSwStats => 1,
                                  NetStats  => 1,
                                  SockStats => 1,
                                  DiskStats => 1,
                                  DiskUsage => 1,
                                  LoadAVG   => 1,
                                  Processes => 1,
                                  TimeStamp => 1 );
.PP
\&\fIsleep\fR\|(1);
.PP
my \f(CW$stats\fR = \f(CW$obj\fR\->getStats;
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module collects system statistics like processor workload, memory usage and other
system informations from the /proc filesystem. It is tested on x86 hardware with the
distributions SuSE, \s-1SLES\s0 (s390 and s390x), Red Hat, Debian and Mandrake on kernel versions
2.4 and 2.6 but should also running on other linux distributions with the same kernel
release number. To run this module it is necessary to start it as root or another user
with the authorization to read the /proc filesystem and the /etc/passwd file.
.Sh "\s-1NOTE\s0"
.IX Subsection "NOTE"
The method \fInew()\fR checks the options and initialize different statitistics if they're required.
If you want to get useful statistics for the options ProcStats, NetStats, DiskStats, PgSwStats
and Processes then it's necessary to sleep for a while \- at least one second \- between the calls
of \fInew()\fR and \fIgetStats()\fR. If you shouldn't do that it's possible that this statistics will be null.
The reason is that this statistics are deltas since the last time that the new method was called
and the call of \fIgetStats()\fR.
.PP
The \fIgetStats()\fR function collects the requested informations and actualize the initalized values.
This way making it possible that the method \fInew()\fR doesn't must called again and again if you want
to collect the statistics in a loop. The exception is that you must call the method \fInew()\fR if you
want to add or remove a option.
.SH "OPTIONS"
.IX Header "OPTIONS"
All options returns a multidimensional hash as a reference with the collected system informations.
.Sh "SysInfo"
.IX Subsection "SysInfo"
Generated from \fI/proc/sys/kernel/hostname\fR *domainname *ostype *osrelease *version
and \fI/proc/sysinfo\fR, \fI/proc/cpuinfo\fR, \fI/proc/meminfo\fR, \fI/proc/uptime\fR.
.PP
.Vb 12
\&   Hostname        -  This is the host name.
\&   Domain          -  This is the host domain name.
\&   Kernel          -  This is the kernel name.
\&   Release         -  This is the release number.
\&   Version         -  This is the version number.
\&   MemTotal        -  The total size of memory.
\&   SwapTotal       -  The total size of swap space.
\&   CPU_Power       -  The power of the CPUs in mhz or bogomips.
\&   CountCPUs       -  The total number of CPUs.
\&   ModelName       -  The model name.
\&   Uptime          -  This is the uptime of the system.
\&   IdleTime        -  This is the idle time of the system idletime.
.Ve
.Sh "ProcStats"
.IX Subsection "ProcStats"
Generated from \fI/proc/stat\fR.
.PP
.Vb 7
\&   User            -  Percentage of CPU utilization at the user level.
\&   Nice            -  Percentage of CPU utilization at the user level with nice priority.
\&   System          -  Percentage of CPU utilization at the system level.
\&   Idle            -  Percentage of time the CPU is in idle state.
\&   IOWait          -  Percentage of time the CPU is in idle state because an i/o operation is waiting for a disk.
\&   Total           -  Total percentage of CPU utilization at user and system level.
\&   New             -  Number of new processes that were produced per second.
.Ve
.Sh "MemStats"
.IX Subsection "MemStats"
Generated from \fI/proc/meminfo\fR.
.PP
.Vb 10
\&   MemUsed         -  Total size of used memory in kilobytes.
\&   MemFree         -  Total size of free memory in kilobytes.
\&   MemUsedFree     -  Total size of used memory in percent.
\&   MemTotal        -  Total size of memory in kilobytes.
\&   Buffers         -  Total size of buffers used from memory in kilobytes.
\&   Cached          -  Total size of cached memory in kilobytes.
\&   SwapUsed        -  Total size of swap space is used is kilobytes.
\&   SwapFree        -  Total size of swap space is free in kilobytes.
\&   SwapUsedPro     -  Total size of swap space is used in percent.
\&   SwapTotal       -  Total size of swap space in kilobytes.
.Ve
.Sh "PgSwStats"
.IX Subsection "PgSwStats"
Generated from \fI/proc/stat\fR or \fI/proc/vmstat\fR.
.PP
.Vb 4
\&   PageIn          -  Number of kilobytes the system has paged in from disk per second.
\&   PageOut         -  Number of kilobytes the system has paged out to disk per second.
\&   SwapIn          -  Number of kilobytes the system has swapped in from disk per second.
\&   SwapOut         -  Number of kilobytes the system has swapped out to disk per second.
.Ve
.Sh "NetStats"
.IX Subsection "NetStats"
Generated from \fI/proc/net/dev\fR.
.PP
.Vb 16
\&   RxBytes         -  Number of bytes received per second.
\&   RxPackets       -  Number of packets received per second.
\&   RxErrs          -  Number of errors that happend per second while received packets.
\&   RxDrop          -  Number of packets that were dropped per second.
\&   RxFifo          -  Number of FIFO overruns that happend per second on received packets.
\&   RxFrame         -  Number of carrier errors that happend per second on received packets.
\&   RxCompr         -  Number of compressed packets received per second.
\&   RxMulti         -  Number of multicast packets received per second.
\&   TxBytes         -  Number of bytes transmitted per second.
\&   TxPacktes       -  Number of packets transmitted per second.
\&   TxErrs          -  Number of errors that happend while transmitting packets.
\&   TxDrop          -  Number of packets that were dropped per second.
\&   TxFifo          -  Number of FIFO overruns that happend per second on transmitted packets.
\&   TxColls         -  Number of collisions that were detected.
\&   TxCarr          -  Number of carrier errors that happend per second on transmitted packets.
\&   TxCompr         -  Number of compressed packets transmitted per second.
.Ve
.Sh "NetStatsSum"
.IX Subsection "NetStatsSum"
.Vb 1
\&   This are just some summaries of NetStats.
.Ve
.PP
.Vb 2
\&   RxBytes         -  Total number of bytes received per second.
\&   TxBytes         -  Total number of bytes transmitted per second.
.Ve
.Sh "SockStats"
.IX Subsection "SockStats"
Generated from \fI/proc/net/sockstat\fR.
.PP
.Vb 5
\&   Used            -  Total number of used sockets.
\&   Tcp             -  Number of tcp sockets in use.
\&   Udp             -  Number of udp sockets in use.
\&   Raw             -  Number of raw sockets in use.
\&   IpFrag          -  Number of ip fragments in use.
.Ve
.Sh "DiskStats"
.IX Subsection "DiskStats"
Generated from \fI/proc/diskstats\fR or \fI/proc/partitions\fR.
.PP
.Vb 8
\&   Major           -  The mayor number of the disk
\&   Minor           -  The minor number of the disk
\&   ReadRequests    -  Number of read requests that were made per second to physical disk.
\&   ReadBytes       -  Number of bytes that were read per second from physical disk.
\&   WriteRequests   -  Number of write requests that were made per second to physical disk.
\&   WriteBytes      -  Number of bytes that were written per second to physical disk.
\&   TotalRequests   -  Total number of requests were made per second from/to physical disk.
\&   TotalBytes      -  Total number of bytes transmitted per second from/to physical disk.
.Ve
.Sh "DiskStatsSum"
.IX Subsection "DiskStatsSum"
.Vb 1
\&   This are just some summaries of DiskStats.
.Ve
.PP
.Vb 6
\&   ReadRequests    -  Total number of read requests were made per second to all physical disks.
\&   ReadBytes       -  Total number of bytes reads per second from all physical disks.
\&   WriteRequests   -  Total number of write requests were made per second to all physical disks.
\&   WriteBytes      -  Total number of bytes written per second to all physical disks.
\&   Requests        -  Total number of requests were made per second from/to all physical disks.
\&   Bytes           -  Total number of bytes transmitted per second from/to all physical disks.
.Ve
.Sh "DiskUsage"
.IX Subsection "DiskUsage"
Generated with \fI/bin/df \-k\fR.
.PP
.Vb 5
\&   Total           -  The total size of the disk.
\&   Usage           -  The used disk space in kilobytes.
\&   Free            -  The free disk space in kilobytes.
\&   UsagePro        -  The used disk space in percent.
\&   MountPoint      -  The moint point of the disk.
.Ve
.Sh "LoadAVG"
.IX Subsection "LoadAVG"
Generated with \fI/proc/loadavg\fR.
.PP
.Vb 5
\&   AVG_1           -  The average processor workload of the last minute.
\&   AVG_5           -  The average processor workload of the last five minutes.
\&   AVG_15          -  The average processor workload of the last fifteen minutes.
\&   RunQueue        -  The number of processes waiting for runtime.
\&   Count           -  The total amount of processes on the system.
.Ve
.Sh "Processes"
.IX Subsection "Processes"
Generated with \fI/proc/<number>/statm\fR, \fI/proc/<number>/stat\fR, \fI/proc/<number>/status\fR, \fI/proc/<number>/cmdline\fR and \fI/etc/passwd\fR.
.PP
.Vb 32
\&   PPid            -  The parent process ID of the process.
\&   Owner           -  The owner name of the process.
\&   State           -  The status of the process.
\&   PGrp            -  The group ID of the process.
\&   Session         -  The session ID of the process.
\&   TTYnr           -  The tty the process use.
\&   MinFLT          -  The number of minor faults the process made per second.
\&   CMinFLT         -  The number of minor faults the child process made per second.
\&   MayFLT          -  The number of mayor faults the process made per second.
\&   CMayFLT         -  The number of mayor faults the child process made per second.
\&   CUTime          -  The number of jiffies the process waited for childrens have been scheduled in user mode.
\&   STime           -  The number of jiffies the process have beed scheduled in kernel mode.
\&   UTime           -  The number of jiffies the process have beed scheduled in user mode.
\&   CSTime          -  The number of jiffies the process waited for childrens have been scheduled in kernel mode.
\&   Prior           -  The priority of the process (+15).
\&   Nice            -  The nice level of the process.
\&   StartTime       -  The time in jiffies the process started after system boot.
\&   ActiveTime      -  The time in D:H:M (days, hours, minutes) the process is active.
\&   VSize           -  The size of virtual memory of the process.
\&   NSwap           -  The size of swap space of the process.
\&   CNSwap          -  The size of swap space of the childrens of the process.
\&   CPU             -  The CPU number the process was last executed on.
\&   Size            -  The total program size of the process.
\&   Resident        -  Number of resident set size, this includes the text, data and stack space.
\&   Share           -  Total size of shared pages of the process.
\&   TRS             -  Total text size of the process.
\&   DRS             -  Total data/stack size of the process.
\&   LRS             -  Total library size of the process.
\&   DT              -  Total size of dirty pages of the process (unused since kernel 2.6).
\&   Comm            -  Command of the process.
\&   CMDLINE         -  Command line of the process.
\&   Pid             -  The process ID.
.Ve
.Sh "TimeStamp"
.IX Subsection "TimeStamp"
Generated with \fIlocaltime(time)\fR.
.PP
.Vb 2
\&   Date            -  The current date.
\&   Time            -  The current time.
.Ve
.SH "EXAMPLES"
.IX Header "EXAMPLES"
A very simple perl script could looks like this:
.IX Subsection "A very simple perl script could looks like this:"
.PP
.Vb 3
\&         #!/usr/bin/perl -w
\&         use strict;
\&         use Linux::Statistics;
.Ve
.PP
.Vb 3
\&         my $obj   = Linux::Statistics->new( ProcStats => 1 );
\&         sleep(1);
\&         my $stats = $obj->getStats;
.Ve
.PP
.Vb 8
\&         print "Statistics for ProcStats\en";
\&         print "  User      $stats->{ProcStats}->{User}\en";
\&         print "  Nice      $stats->{ProcStats}->{Nice}\en";
\&         print "  System    $stats->{ProcStats}->{System}\en";
\&         print "  Idle      $stats->{ProcStats}->{Idle}\en";
\&         print "  IOWait    $stats->{ProcStats}->{IOWait}\en";
\&         print "  Total     $stats->{ProcStats}->{Total}\en";
\&         print "  New       $stats->{ProcStats}->{New}\en";
.Ve
.PP
Or this:
.IX Subsection "Or this:"
.PP
.Vb 3
\&         #!/usr/bin/perl -w
\&         use strict;
\&         use Linux::Statistics;
.Ve
.PP
.Vb 3
\&         my $obj = Linux::Statistics->new( NetStats => 1 );
\&         sleep(1);
\&         my $stats = $obj->getStats;
.Ve
.PP
.Vb 2
\&         foreach my $device (keys %{$stats->{NetStats}}) {
\&            print "Statistics for device $device ...\en";
.Ve
.PP
.Vb 4
\&            while (my ($key,$value) = each %{$stats->{NetStats}->{$device}}) {
\&               print ' ' x 2, "$key", ' ' x (30-length($key)), "$value\en";
\&            }
\&         }
.Ve
.PP
.Vb 1
\&         print "\enTotal network statistics ...\en";
.Ve
.PP
.Vb 3
\&         while (my ($key,$value) = each %{$stats->{NetStatsSum}}) {
\&            print ' ' x 2, "$key", ' ' x (30-length($key)), "$value\en";
\&         }
.Ve
.PP
This also:
.IX Subsection "This also:"
.PP
.Vb 3
\&         #!/usr/bin/perl -w
\&         use strict;
\&         use Linux::Statistics;
.Ve
.PP
.Vb 3
\&         my $obj = Linux::Statistics->new( Processes => 1 );
\&         sleep(1);
\&         my $stats = $obj->getStats;
.Ve
.PP
.Vb 2
\&         print "$_", ' ' x (12-length($_)) for qw(Pid PPid Owner State Size VSize CMDLINE);
\&         print "\en";
.Ve
.PP
.Vb 5
\&         foreach my $pid (keys %{$stats->{Processes}}) {
\&            print "$stats->{Processes}->{$pid}->{$_}", ' ' x (12-length($stats->{Processes}->{$pid}->{$_}))
\&               for qw(Pid PPid Owner State Size VSize CMDLINE);
\&            print "\en";
\&         }
.Ve
.PP
You can also collect the statistics in a loop:
.IX Subsection "You can also collect the statistics in a loop:"
.PP
.Vb 3
\&         #!/usr/bin/perl -w
\&         use strict;
\&         use Linux::Statistics;
.Ve
.PP
.Vb 1
\&         $| = 1;
.Ve
.PP
.Vb 1
\&         my $obj   = Linux::Statistics->new( ProcStats => 1, TimeStamp => 1 );
.Ve
.PP
.Vb 3
\&         print "Report/Statistic for ProcStats\en";
\&         print ' ' x (8-length($_)), "$_" for qw(Time User Nice System Idle IOWait Total New);
\&         print "\en";
.Ve
.PP
.Vb 3
\&         while (1) {
\&            sleep(1);
\&            my $stats = $obj->getStats;
.Ve
.PP
.Vb 4
\&            print "$stats->{TimeStamp}->{Time}";
\&            print ' ' x (8-length($stats->{ProcStats}->{$_})), "$stats->{ProcStats}->{$_}" for keys %{$stats->{ProcStats}};
\&            print "\en";
\&         }
.Ve
.PP
It is also possible to create a hash reference with options.
.IX Subsection "It is also possible to create a hash reference with options."
.PP
.Vb 13
\&         my $options = {
\&            SysInfo   => 1,
\&            ProcStats => 1,
\&            MemStats  => 1,
\&            PgSwStats => 1,
\&            NetStats  => 1,
\&            SockStats => 1,
\&            DiskStats => 1,
\&            DiskUsage => 1,
\&            LoadAVG   => 1,
\&            Processes => 1,
\&            TimeStamp => 1
\&         };
.Ve
.PP
.Vb 3
\&         my $obj = Linux::Statistics->new( $options );
\&         sleep(1);
\&         my $stats = $obj->getStats;
.Ve
.PP
If you're not sure you can use the the Data::Dumper module to learn more about the hash structure.
.IX Subsection "If you're not sure you can use the the Data::Dumper module to learn more about the hash structure."
.PP
.Vb 4
\&         #!/usr/bin/perl -w
\&         use strict;
\&         use Linux::Statistics;
\&         use Data::Dumper;
.Ve
.PP
.Vb 3
\&         my $obj = Linux::Statistics->new( Processes => 1 );
\&         sleep(1);
\&         my $stats = $obj->getStats;
.Ve
.PP
.Vb 1
\&         print Dumper($stats);
.Ve
.PP
You can find a very simple script for tests under the installation directory Linux\-Statistics\-<version>/tests/. The script called SimpleCheck.pl and shows you the collected data with Data::Dumper.
.IX Subsection "You can find a very simple script for tests under the installation directory Linux-Statistics-<version>/tests/. The script called SimpleCheck.pl and shows you the collected data with Data::Dumper."
.PP
Have a lot of fun with this module :\-)
.IX Subsection "Have a lot of fun with this module :-)"
.SH "SEE ALSO"
.IX Header "SEE ALSO"
The manpage of \fIproc\fR\|(5) or \fI/usr/src/linux/Documentation/filesystems/proc.txt\fR.
.SH "REPORTING BUGS"
.IX Header "REPORTING BUGS"
Please report all bugs to <jschulz@bloonix.de>.
.PP
You can send me additional informations generated by a script if you like.
The script should lie under the Linus\-Statistics\-<version>/tests/ directory
and it called ProcCheck.pl. This script generates an output for all statistics
with Data::Dumper and an output of all necessary files from the /proc filesystem.
Take a look into this script and take care that it only generates data from
this files. The output file called output_proc_check.txt.
.SH "AUTHOR"
.IX Header "AUTHOR"
Jonny Schulz <jschulz@bloonix.de>.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2005, 2006 by Jonny Schulz. All rights reserved.
.PP
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
